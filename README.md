# java-design-patterns

## Class Diagram
- Association 관계: 지속적으로 사용  ->
- Aggregation 관계 : 다른 객체를 포함 (생명주기 다름, 재활용 가능) ◇->
- Composition 관계 : 다른 객체를 포함 (생명주기 같음) ◆->
- Dependency 관계 : 일시적으로 사용 -->
- extends 관계 -▷
- implements 관계 --▷



## 자바 디자인 패턴
**1. Iterator**  
순서를 지정해서 처리하기  
무엇인가 많이 모여있는 것들을 순서대로 지정하면서 전체를 검색하는 처리를 실행
  
**2. ClassAdapter**  
상속을 사용한 Adapter 패턴  
'이미 제공되어 있는 것'과 필요한 것' 사이의 '차이'를 없앰  
인터페이스 호환성 문제 때문에 같이 쓸 수 없는 클래스들을 연결해서 쓸 수 있다

**3. ObjectAdapter**  
위임을 사용한 Adapter 패턴  

**4.Template Method**  
하위 클래스에서 구체적으로 처리하기

**5. Factory Method**  
하위 클래스에서 인스턴스 작성하기

**6. Singleton**  
인스턴스를 한 개만 만들기

**7. Prototype**  
복사해서 인스턴스 만들기  
인스턴스를 생성하는 것이 아니라 인스턴스로부터 별도의 인스턴스를 만드는 패턴  
이럴 때 사용!  
1) 종류가 너무 많아 클래스로 정리되지 않는 경우  
2) 클래스로부터 인스턴스 생성이 어려운 경우  
3) framework와 생성할 인스턴스를 분리하고 싶은 경우


**8. Builder**  
복잡한 인스턴스를 조립하기  
객체를 생성할 때 흔히 사용되는 패턴 - [[참조]](https://johngrib.github.io/wiki/builder-pattern/)  
각 인자가 어떤 의미인지 알기 쉽고 setter 메서드가 없으므로 변경 불가능한 객체를 만들 수 있다.

**9. Abstract Factory**  
관련 부품을 조합해서 제품 만들기  
여러 종류의 객체를 생성할 때 객체들 사이의 관련성이 있는 경우 사용  
부품별로 Factory 클래스를 만드는 대신 제조업체별로 Factory 클래스를 만들 수 있다. - [[참조]](https://gmlwjd9405.github.io/2018/08/08/abstract-factory-pattern.html)  
예) SqlSessionFactory

**10. Bridge**  
기능 계층과 구현 계층 분리하기  
분리하여 각각의 클래스 계층을 독립적으로 확장할 수 있다.  
상속은 견고한 연결이고 위임은 느슨한 연결이다.  

**11. Strategy**  
알고리즘을 모두 바꾸기  
알고리즘을 구현한 부분을 교환할 수 있게 (실행 중에도 가능)

**12. Composite**  
그릇과 내용물을 동일시해서 재귀적인 구조를 만들기 위한 패턴  
예) 디렉터리와 파일은 서로 다르지만 모두 '디렉터리 안에 넣을 수 있는것' => '디렉터리 엔트리'

**13. Decorator**  
장식과 내용물을 동일시하기  
오브젝트에 장식을 해 나가는 디자인 패턴  
예) BufferedReader

**14. Visitor**  
데이터 구조를 돌아다니면서 처리하기  
데이터 구조와 처리를 분리. 데이터 구조 안을 돌아다니는 주체인 '방문자'를 나타내는 
클래스를 준비해서 그 클래스에게 처리를 위임.  
> 예제코드) 파일과 디렉터리로 구성된 데이터 구조 안을 방문자가 돌아다니고 표시하는 코드

**15. Chain of Responsibility**  
책임 떠넘기기  
어떤 요청이 발생했을 때 그 요청을 처리할 오브젝트를 직접 결정할 수 없는 경우,  
복수의 오브젝트(객체)를 사슬(chain)처럼 연결해 두면, 그 오브젝트(객체)의
사슬을 차례로 돌아다니면서 목적한 오브젝트(객체)를 결정하는 방법 

**16. Facade**  
단순한 창구  

**17. Mediator**  
중개인을 통해서 처리하기  
회원들은 모두 중개인에게만 보고를 하고, 중개인만이 회원에게 지시를 내릴 수 있다.  
Mediator는 쌍방향이지만 Facade는 단방향  
> 예제코드) 로그인 다이얼로그 GUI 어플리케이션  

**18. Observer**  
상태의 변화를 알려주기  
상태 변화에 따른 처리를 기술할 때 효과적  
Mediator 패턴에서도 상태변화를 알리지만, 그것은 Colleague 역할의 조정이라는 목적으로 동작  
Observer 패턴에서는 Subject 역할의 상태변화를 Observer 역할에게 알려 동기화를 이루는 일에 주안점을 둔다.  
> 예제코드) 랜덤 넘버 옵저버

**19. Memento**  
상태를 저장하기  

**20. State**  
상태를 클래스로 표현하기  
> 예제코드) 금고경비 시스템

**21. Flyweight**  
동일한 것을 공유해서 낭비 없애기  
'인스턴스를 가능한 대로 공유시켜서 쓸데없이 new하지 않도록 한다'  
공유시키는 정보는 <u>'intrinsic한 정보'</u>  
공유시키지 않는 정보는 <u>'extrinsic한 정보'</u> 즉 상태에 의존하는 정보

**22. Proxy**  
- 필요해지면 만들기  
- Proxy 역할은 Client 역할의 요구를 할 수 있는 만큼 처리한다. 만약, 자신만으로 처리할 수 없으면 
RealSubject 역할에게 처리를 맡긴다. 정말로 RealSubject 역할이 필요해지면 
그때 RealSubject 역할을 생성한다.  
- 어플리케이션의 기동에 시간이 많이 걸리는 문제 개선  
- 예) HTTP Proxy

